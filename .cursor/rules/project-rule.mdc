## Project Rules (Coding Only)

前提: Next.js (App Router) + TypeScript + Tailwind CSS + shadcn/ui + microCMS

---

### 1. ディレクトリ/ファイル構造と命名規則

- **エイリアス**: `@/*` は `src/*` を指す。相対参照は 2 階層以上を避け、極力 `@/` を使用。
- **層構造**:
  - `src/app/`:
    - ルーティング（App Router）。フォルダ名は URL に一致。`(site)` のようなグルーピングは OK。
    - ページは原則サーバーコンポーネント。クライアントが必要な場合のみ `"use client"` を先頭に付与。
    - ルートごとのデータ取得はサーバー側で行い、`features/*/api.ts` 経由で呼ぶ。
  - `src/components/`:
    - **純粋 UI 再利用コンポーネント**を置く。粒度は小～中。ドメイン知識は含めない。
    - サブフォルダは役割単位（例: `layout/`, `form/`, `data-display/`）。
  - `src/features/<domain>/`:
    - ドメイン単位の集約。例: `works/`。
    - `api.ts`（ドメイン用 fetch 集約）/ `types.ts`（ドメイン型）/ 必要に応じて `components/` を配置。
  - `src/lib/`:
    - 外部サービス・クライアントの初期化や共通ラッパ（例: `microcms.ts`）。
  - `src/types/`:
    - 横断的・共通の型。ドメイン固有は `features/*/types.ts` に置き、必要に応じて再エクスポート。
  - `src/utils/`:
    - 副作用のない純関数。用途別ファイルに分割し、`src/utils/index.ts` でサーフェスを整理。
  - `src/styles/`:
    - グローバル CSS と Tailwind 設定拡張。コンポーネント内は可能な限りユーティリティクラスで完結。
- **命名**:
  - ディレクトリ/ファイルは `kebab-case`。React コンポーネントファイル名のみ `PascalCase.tsx` を許可。
  - 型は `PascalCase`、変数/関数は `camelCase`、定数は `UPPER_SNAKE_CASE`（ドメインのエンドポイント名なども）。
  - API 関数は動詞始まり（例: `getWorks`, `getWorkBySlug`）。

### 2. React コンポーネントの書き方

- **エクスポート**:
  - 単一コンポーネント/フックは `export const` の名前付きエクスポート。デフォルトエクスポートは使用しない。
- **Props**:
  - Props は `interface` または `type` で `PascalCase` 命名（例: `WorkCardProps`）。
  - 可能な限り必須/任意を厳密化。`?` よりもユニオンで意味を表現。
  - 子要素は `children?: React.ReactNode`。
- **コンポーネント種別**:
  - 既定はサーバーコンポーネント。クライアントが必要な条件：イベントハンドラ、`useState`/`useEffect`、ブラウザ API 依存、shadcn の一部インタラクティブ UI。
  - クライアント化はファイル先頭にのみ `"use client"` を宣言。
- **アクセシビリティ**:
  - 画像は `alt` 必須、インタラクティブ要素には適切な `role`/`aria-*` を付与。
- **エラーハンドリング**:
  - フェッチ失敗時は上位でハンドル。UI ではフォールバック表示を実装（例: 空配列時のプレースホルダ）。
- **フォルダ単位の公開面**:
  - `index.ts` を置いて公開 API を明示的に制御（`export { ComponentA } from './ComponentA'`）。

### 3. Tailwind / shadcn/ui の方針

- **Tailwind 基本**:
  - スタイルはまずユーティリティクラスで構築。複雑化したらコンポーネント化。
  - 任意の再利用スタイルは `@layer components` に抽出、または `cn()` でプリセット化。
- **命名と順序**:
  - クラス順序は論理グループで整列：レイアウト → サイズ → 余白 → フレックス/グリッド → タイポ → 色 → 効果。
- **ダークモード**:
  - 変数は `:root` で宣言済み。必要に応じ `dark:` プレフィックスを使用。
- **shadcn/ui**:
  - 追加コンポーネントは `components/ui/` に設置。自動生成後もプロジェクト規約（命名/エクスポート/型）に合わせて調整。
  - スタイリングは極力プロップスとユーティリティクラスで。大規模上書きは避ける。
  - ヘルパ `cn(...classes)` を用意し、条件クラス分岐を簡潔に（`classnames`相当）。

### 4. microCMS API 接続のルール

- **クライアント**:
  - `src/lib/microcms.ts` にて `createClient` を一元管理。`MICROCMS_SERVICE_DOMAIN` と `MICROCMS_API_KEY` が必須。エラー時は起動時に例外。
- **ドメイン API**:
  - ドメイン固有の取得関数は `src/features/<domain>/api.ts` に集約。
  - 取得関数は戻り値をドメイン型にキャスト/整形して返す（UI はドメイン型のみを参照）。
  - エラーログは `console.error`、上位にはメッセージ付き `Error` or `null/[]` を返す方針を統一。
- **型定義**:
  - 共通型は `src/types/`、ドメイン型は `src/features/<domain>/types.ts`。必要に応じ `src/types/index.ts` から再エクスポート。
  - microCMS のレスポンス基本型は `MicroCMSResponse<T>` / `MicroCMSContentBase` を使用。
- **クエリ/フィルタ**:
  - ページングは `limit`/`offset` を引数化。`orders` などの既定は lib 側でデフォルト実装を持つ。
  - スラッグ検索などのクエリは lib 側に共通関数（`getContentBySlug`）を置き再利用。
- **キャッシュ**:
  - サーバーコンポーネントのフェッチはデフォルトで SSR。必要に応じて `revalidate` の設定をページ側で指定。

### 5. コーディングスタイル

- **言語/型**:
  - TypeScript は `strict: true` 前提。`any` は禁止。必要な場合は限定的な型ガードを実装。
  - 関数は動詞句、変数は名詞句。略語は避け、意味のある名称を使用。
- **コメント**:
  - 明確な意図がある場合のみ。なぜ（Why）を短く上に記述。自明なコメントは書かない。
- **エラーハンドリング**:
  - 外部 I/O 境界（fetch, SDK）は `try/catch`。UI 層ではエラー文言をユーザー向けに調整。
- **フォーマット/リンティング**:
  - `eslint-config-next` を継続利用。エラーはゼロを維持。
  - import 並びは自動整形に従う。未使用の import/変数はコミット前に削除。
- **アクセシビリティ/国際化**:
  - テキストは日本語デフォルト。将来の i18n に備え、ハードコード文面は最小限に。

### 6. 具体例（本プロジェクトに即した）

- `src/lib/microcms.ts`:
  - `getAllContents(endpoint, limit, offset)` は `orders: '-publishedAt'` を既定とする。
  - `getContentBySlug(endpoint, slug)` を共通化し、features で再利用。
- `src/features/works/api.ts`:
  - `WORKS_ENDPOINT` は `UPPER_SNAKE_CASE`。
  - UI 層は `Work`/`WorksResponse` のみ参照し、microCMS の生データへの依存を避ける。

### 7. PR/コミット運用（簡易）

- 1 コミット 1 論点。型・命名・フォーマット修正は機能改修と分離。
- 変更箇所には根拠（仕様/ルール）を PR 説明に 1-2 行で明記。

### 8. 対象外（ツール/運用設定）

- MCP（Model Context Protocol）/ `.cursor` 設定、エディタ拡張、CI 設定、Git フック、デプロイ設定は本ドキュメントの範囲外。
- 本ドキュメントは「コーディングに関するルール」に限定。運用・ツール設定は別ドキュメント（Ops/Tooling Rules）で管理する。
